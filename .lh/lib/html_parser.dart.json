{
    "sourceFile": "lib/html_parser.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1720995828138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1720995828138,
            "name": "Commit-0",
            "content": "import 'dart:collection';\nimport 'dart:math';\n\nimport 'package:collection/collection.dart';\nimport 'package:csslib/parser.dart' as cssparser;\nimport 'package:csslib/visitor.dart' as css;\nimport 'package:flutter/material.dart';\nimport 'package:flutter_html/flutter_html.dart';\nimport 'package:flutter_html/src/css_parser.dart';\nimport 'package:flutter_html/src/html_elements.dart';\nimport 'package:flutter_html/src/utils.dart';\nimport 'package:html/dom.dart' as dom;\nimport 'package:html/parser.dart' as htmlparser;\nimport 'package:numerus/numerus.dart';\n\ntypedef OnTap = void Function(\n  String? url,\n  RenderContext context,\n  Map<String, String> attributes,\n  dom.Element? element,\n);\ntypedef OnCssParseError = String? Function(\n  String css,\n  List<cssparser.Message> errors,\n);\n\nclass HtmlParser extends StatelessWidget {\n  final dom.Element htmlData;\n  final OnTap? onLinkTap;\n  final OnTap? onAnchorTap;\n  final OnTap? onImageTap;\n  final OnCssParseError? onCssParseError;\n  final ImageErrorListener? onImageError;\n  final bool shrinkWrap;\n  final bool selectable;\n\n  final Map<String, Style> style;\n  final Map<CustomRenderMatcher, CustomRender> customRenders;\n  final List<String> tagsList;\n  final OnTap? internalOnAnchorTap;\n  final Html? root;\n  final TextSelectionControls? selectionControls;\n  final ScrollPhysics? scrollPhysics;\n\n  final Map<String, Size> cachedImageSizes = {};\n\n  HtmlParser({\n    required super.key,\n    required this.htmlData,\n    required this.onLinkTap,\n    required this.onAnchorTap,\n    required this.onImageTap,\n    required this.onCssParseError,\n    required this.onImageError,\n    required this.shrinkWrap,\n    required this.selectable,\n    required this.style,\n    required this.customRenders,\n    required this.tagsList,\n    this.root,\n    this.selectionControls,\n    this.scrollPhysics,\n  }) : internalOnAnchorTap = onAnchorTap ??\n            (key != null ? _handleAnchorTap(key, onLinkTap) : onLinkTap);\n\n  /// As the widget [build]s, the HTML data is processed into a tree of [StyledElement]s,\n  /// which are then parsed into an [InlineSpan] tree that is then rendered to the screen by Flutter\n  //TODO Lazy processing of data. We don't need the processing steps done every build phase unless the data has changed.\n  @override\n  Widget build(BuildContext context) {\n    // Lexing Step\n    StyledElement lexedTree = lexDomTree(\n      htmlData,\n      customRenders.keys.toList(),\n      tagsList,\n      context,\n      this,\n    );\n\n    // Styling Step\n    StyledElement styledTree =\n        styleTree(lexedTree, htmlData, style, onCssParseError);\n\n    // Processing Step\n    StyledElement processedTree =\n        processTree(styledTree, MediaQuery.of(context).devicePixelRatio);\n\n    // Parsing Step\n    InlineSpan parsedTree = parseTree(\n      RenderContext(\n        buildContext: context,\n        parser: this,\n        tree: processedTree,\n        style: processedTree.style,\n      ),\n      processedTree,\n    );\n\n    return CssBoxWidget.withInlineSpanChildren(\n      style: processedTree.style,\n      children: [parsedTree],\n      selectable: selectable,\n      scrollPhysics: scrollPhysics,\n      selectionControls: selectionControls,\n      shrinkWrap: shrinkWrap,\n    );\n  }\n\n  /// [parseHTML] converts a string of HTML to a DOM element using the dart `html` library.\n  static dom.Element parseHTML(String data) {\n    return htmlparser.parse(data).documentElement!;\n  }\n\n  /// [parseCss] converts a string of CSS to a CSS stylesheet using the dart `csslib` library.\n  static css.StyleSheet parseCss(String data) {\n    return cssparser.parse(data);\n  }\n\n  /// [lexDomTree] converts a DOM document to a simplified tree of [StyledElement]s.\n  static StyledElement lexDomTree(\n    dom.Element html,\n    List<CustomRenderMatcher> customRenderMatchers,\n    List<String> tagsList,\n    BuildContext context,\n    HtmlParser parser,\n  ) {\n    StyledElement tree = StyledElement(\n      name: \"[Tree Root]\",\n      children: <StyledElement>[],\n      node: html,\n      //TODO(Sub6Resources): This seems  difficult to customize\n      style: Style.fromTextStyle(Theme.of(context).textTheme.bodyMedium!),\n    );\n\n    for (var node in html.nodes) {\n      tree.children.add(_recursiveLexer(\n        node,\n        customRenderMatchers,\n        tagsList,\n        context,\n        parser,\n      ));\n    }\n\n    return tree;\n  }\n\n  /// [_recursiveLexer] is the recursive worker function for [lexDomTree].\n  ///\n  /// It runs the parse functions of every type of\n  /// element and returns a [StyledElement] tree representing the element.\n  static StyledElement _recursiveLexer(\n    dom.Node node,\n    List<CustomRenderMatcher> customRenderMatchers,\n    List<String> tagsList,\n    BuildContext context,\n    HtmlParser parser,\n  ) {\n    List<StyledElement> children = <StyledElement>[];\n\n    for (var childNode in node.nodes) {\n      children.add(_recursiveLexer(\n        childNode,\n        customRenderMatchers,\n        tagsList,\n        context,\n        parser,\n      ));\n    }\n\n    //TODO(Sub6Resources): There's probably a more efficient way to look this up.\n    if (node is dom.Element) {\n      if (!tagsList.contains(node.localName)) {\n        return EmptyContentElement();\n      }\n      if (HtmlElements.styledElements.contains(node.localName)) {\n        return parseStyledElement(node, children);\n      } else if (HtmlElements.interactableElements.contains(node.localName)) {\n        return parseInteractableElement(node, children);\n      } else if (HtmlElements.replacedElements.contains(node.localName)) {\n        return parseReplacedElement(node, children);\n      } else if (HtmlElements.layoutElements.contains(node.localName)) {\n        return parseLayoutElement(node, children);\n      } else if (HtmlElements.tableCellElements.contains(node.localName)) {\n        return parseTableCellElement(node, children);\n      } else if (HtmlElements.tableDefinitionElements\n          .contains(node.localName)) {\n        return parseTableDefinitionElement(node, children);\n      } else {\n        final StyledElement tree = parseStyledElement(node, children);\n        for (final entry in customRenderMatchers) {\n          if (entry.call(\n            RenderContext(\n              buildContext: context,\n              parser: parser,\n              tree: tree,\n              style:\n                  Style.fromTextStyle(Theme.of(context).textTheme.bodyMedium!),\n            ),\n          )) {\n            return tree;\n          }\n        }\n        return EmptyContentElement();\n      }\n    } else if (node is dom.Text) {\n      return TextContentElement(\n        text: node.text,\n        style: Style(),\n        element: node.parent,\n        node: node,\n      );\n    } else {\n      return EmptyContentElement();\n    }\n  }\n\n  static Map<String, Map<String, List<css.Expression>>>\n      _getExternalCssDeclarations(\n          List<dom.Element> styles, OnCssParseError? errorHandler) {\n    String fullCss = \"\";\n    for (final e in styles) {\n      fullCss = fullCss + e.innerHtml;\n    }\n    if (fullCss.isNotEmpty) {\n      final declarations = parseExternalCss(fullCss, errorHandler);\n      return declarations;\n    } else {\n      return {};\n    }\n  }\n\n  static StyledElement _applyExternalCss(\n      Map<String, Map<String, List<css.Expression>>> declarations,\n      StyledElement tree) {\n    declarations.forEach((key, style) {\n      try {\n        if (tree.matchesSelector(key)) {\n          tree.style = tree.style.merge(declarationsToStyle(style));\n        }\n      } catch (_) {}\n    });\n\n    for (var element in tree.children) {\n      _applyExternalCss(declarations, element);\n    }\n\n    return tree;\n  }\n\n  static StyledElement _applyInlineStyles(\n      StyledElement tree, OnCssParseError? errorHandler) {\n    if (tree.attributes.containsKey(\"style\")) {\n      final newStyle = inlineCssToStyle(tree.attributes['style'], errorHandler);\n      if (newStyle != null) {\n        tree.style = tree.style.merge(newStyle);\n      }\n    }\n\n    for (var element in tree.children) {\n      _applyInlineStyles(element, errorHandler);\n    }\n    return tree;\n  }\n\n  /// [applyCustomStyles] applies the [Style] objects passed into the [Html]\n  /// widget onto the [StyledElement] tree, no cascading of styles is done at this point.\n  static StyledElement _applyCustomStyles(\n      Map<String, Style> style, StyledElement tree) {\n    style.forEach((key, style) {\n      try {\n        if (tree.matchesSelector(key)) {\n          tree.style = tree.style.merge(style);\n        }\n      } catch (_) {}\n    });\n    for (var element in tree.children) {\n      _applyCustomStyles(style, element);\n    }\n\n    return tree;\n  }\n\n  /// [_cascadeStyles] cascades all of the inherited styles down the tree, applying them to each\n  /// child that doesn't specify a different style.\n  static StyledElement _cascadeStyles(\n      Map<String, Style> style, StyledElement tree) {\n    for (var child in tree.children) {\n      child.style = tree.style.copyOnlyInherited(child.style);\n      _cascadeStyles(style, child);\n    }\n\n    return tree;\n  }\n\n  /// [styleTree] takes the lexed [StyleElement] tree and applies external,\n  /// inline, and custom CSS/Flutter styles, and then cascades the styles down the tree.\n  static StyledElement styleTree(StyledElement tree, dom.Element htmlData,\n      Map<String, Style> style, OnCssParseError? onCssParseError) {\n    Map<String, Map<String, List<css.Expression>>> declarations =\n        _getExternalCssDeclarations(\n            htmlData.getElementsByTagName(\"style\"), onCssParseError);\n\n    StyledElement? externalCssStyledTree;\n    if (declarations.isNotEmpty) {\n      externalCssStyledTree = _applyExternalCss(declarations, tree);\n    }\n    tree = _applyInlineStyles(externalCssStyledTree ?? tree, onCssParseError);\n    tree = _applyCustomStyles(style, tree);\n    tree = _cascadeStyles(style, tree);\n    return tree;\n  }\n\n  /// [processTree] optimizes the [StyledElement] tree so all [BlockElement]s are\n  /// on the first level, redundant levels are collapsed, empty elements are\n  /// removed, and specialty elements are processed.\n  static StyledElement processTree(\n      StyledElement tree, double devicePixelRatio) {\n    tree = _processInternalWhitespace(tree);\n    tree = _processInlineWhitespace(tree);\n    tree = _removeEmptyElements(tree);\n\n    tree = _calculateRelativeValues(tree, devicePixelRatio);\n    tree = _processListCharacters(tree);\n    tree = _processBeforesAndAfters(tree);\n    tree = _collapseMargins(tree);\n    return tree;\n  }\n\n  /// [parseTree] converts a tree of [StyledElement]s to an [InlineSpan] tree.\n  ///\n  /// [parseTree] is responsible for handling the [customRenders] parameter and\n  /// deciding what different `Style.display` options look like as Widgets.\n  InlineSpan parseTree(RenderContext context, StyledElement tree) {\n    // Merge this element's style into the context so that children\n    // inherit the correct style\n    RenderContext newContext = RenderContext(\n      buildContext: context.buildContext,\n      parser: this,\n      tree: tree,\n      style: context.style.copyOnlyInherited(tree.style),\n      key: AnchorKey.of(key, tree),\n    );\n\n    for (final entry in customRenders.keys) {\n      if (entry.call(newContext)) {\n        buildChildren() =>\n            tree.children.map((tree) => parseTree(newContext, tree)).toList();\n        if (newContext.parser.selectable &&\n            customRenders[entry] is SelectableCustomRender) {\n          selectableBuildChildren() => tree.children\n              .map((tree) => parseTree(newContext, tree) as TextSpan)\n              .toList();\n          return (customRenders[entry] as SelectableCustomRender)\n              .textSpan\n              .call(newContext, selectableBuildChildren);\n        }\n        if (newContext.parser.selectable) {\n          return customRenders[entry]!\n              .inlineSpan!\n              .call(newContext, buildChildren) as TextSpan;\n        }\n        if (customRenders[entry]?.inlineSpan != null) {\n          return customRenders[entry]!\n              .inlineSpan!\n              .call(newContext, buildChildren);\n        }\n        return WidgetSpan(\n          child: CssBoxWidget(\n            style: tree.style,\n            shrinkWrap: newContext.parser.shrinkWrap,\n            childIsReplaced: true, //TODO is this true?\n            child:\n                customRenders[entry]!.widget!.call(newContext, buildChildren),\n          ),\n        );\n      }\n    }\n    return const WidgetSpan(child: SizedBox(height: 0, width: 0));\n  }\n\n  static OnTap _handleAnchorTap(Key key, OnTap? onLinkTap) => (String? url,\n          RenderContext context,\n          Map<String, String> attributes,\n          dom.Element? element) {\n        if (url?.startsWith(\"#\") == true) {\n          final anchorContext =\n              AnchorKey.forId(key, url!.substring(1))?.currentContext;\n          if (anchorContext != null) {\n            Scrollable.ensureVisible(anchorContext);\n          }\n          return;\n        }\n        onLinkTap?.call(url, context, attributes, element);\n      };\n\n  /// [processWhitespace] removes unnecessary whitespace from the StyledElement tree.\n  ///\n  /// The criteria for determining which whitespace is replaceable is outlined\n  /// at https://www.w3.org/TR/css-text-3/\n  /// and summarized at https://medium.com/@patrickbrosset/when-does-white-space-matter-in-html-b90e8a7cdd33\n  static StyledElement _processInternalWhitespace(StyledElement tree) {\n    if ((tree.style.whiteSpace ?? WhiteSpace.normal) == WhiteSpace.pre) {\n      // Preserve this whitespace\n    } else if (tree is TextContentElement) {\n      tree.text = _removeUnnecessaryWhitespace(tree.text!);\n    } else {\n      tree.children.forEach(_processInternalWhitespace);\n    }\n    return tree;\n  }\n\n  /// [_processInlineWhitespace] is responsible for removing redundant whitespace\n  /// between and among inline elements. It does so by creating a boolean [Context]\n  /// and passing it to the [_processInlineWhitespaceRecursive] function.\n  static StyledElement _processInlineWhitespace(StyledElement tree) {\n    tree = _processInlineWhitespaceRecursive(tree, Context(false));\n    return tree;\n  }\n\n  /// [_processInlineWhitespaceRecursive] analyzes the whitespace between and among different\n  /// inline elements, and replaces any instance of two or more spaces with a single space, according\n  /// to the w3's HTML whitespace processing specification linked to above.\n  static StyledElement _processInlineWhitespaceRecursive(\n    StyledElement tree,\n    Context<bool> keepLeadingSpace,\n  ) {\n    if (tree is TextContentElement) {\n      /// initialize indices to negative numbers to make conditionals a little easier\n      int textIndex = -1;\n      int elementIndex = -1;\n\n      /// initialize parent after to a whitespace to account for elements that are\n      /// the last child in the list of elements\n      String parentAfterText = \" \";\n\n      /// find the index of the text in the current tree\n      if ((tree.element?.nodes.length ?? 0) >= 1) {\n        textIndex =\n            tree.element?.nodes.indexWhere((element) => element == tree.node) ??\n                -1;\n      }\n\n      /// get the parent nodes\n      dom.NodeList? parentNodes = tree.element?.parent?.nodes;\n\n      /// find the index of the tree itself in the parent nodes\n      if ((parentNodes?.length ?? 0) >= 1) {\n        elementIndex =\n            parentNodes?.indexWhere((element) => element == tree.element) ?? -1;\n      }\n\n      /// if the tree is any node except the last node in the node list and the\n      /// next node in the node list is a text node, then get its text. Otherwise\n      /// the next node will be a [dom.Element], so keep unwrapping that until\n      /// we get the underlying text node, and finally get its text.\n      if (elementIndex < (parentNodes?.length ?? 1) - 1 &&\n          parentNodes?[elementIndex + 1] is dom.Text) {\n        parentAfterText = parentNodes?[elementIndex + 1].text ?? \" \";\n      } else if (elementIndex < (parentNodes?.length ?? 1) - 1) {\n        var parentAfter = parentNodes?[elementIndex + 1];\n        while (parentAfter is dom.Element) {\n          if (parentAfter.nodes.isNotEmpty) {\n            parentAfter = parentAfter.nodes.first;\n          } else {\n            break;\n          }\n        }\n        parentAfterText = parentAfter?.text ?? \" \";\n      }\n\n      /// If the text is the first element in the current tree node list, it\n      /// starts with a whitespace, it isn't a line break, either the\n      /// whitespace is unnecessary or it is a block element, and either it is\n      /// first element in the parent node list or the previous element\n      /// in the parent node list ends with a whitespace, delete it.\n      ///\n      /// We should also delete the whitespace at any point in the node list\n      /// if the previous element is a <br> because that tag makes the element\n      /// act like a block element.\n      if (textIndex < 1 &&\n          tree.text!.startsWith(' ') &&\n          tree.element?.localName != \"br\" &&\n          (!keepLeadingSpace.data || tree.style.display == Display.block) &&\n          (elementIndex < 1 ||\n              (elementIndex >= 1 &&\n                  parentNodes?[elementIndex - 1] is dom.Text &&\n                  parentNodes![elementIndex - 1].text!.endsWith(\" \")))) {\n        tree.text = tree.text!.replaceFirst(' ', '');\n      } else if (textIndex >= 1 &&\n          tree.text!.startsWith(' ') &&\n          tree.element?.nodes[textIndex - 1] is dom.Element &&\n          (tree.element?.nodes[textIndex - 1] as dom.Element).localName ==\n              \"br\") {\n        tree.text = tree.text!.replaceFirst(' ', '');\n      }\n\n      /// If the text is the last element in the current tree node list, it isn't\n      /// a line break, and the next text node starts with a whitespace,\n      /// update the [Context] to signify to that next text node whether it should\n      /// keep its whitespace. This is based on whether the current text ends with a\n      /// whitespace.\n      if (textIndex == (tree.element?.nodes.length ?? 1) - 1 &&\n          tree.element?.localName != \"br\" &&\n          parentAfterText.startsWith(' ')) {\n        keepLeadingSpace.data = !tree.text!.endsWith(' ');\n      }\n    }\n\n    for (var element in tree.children) {\n      _processInlineWhitespaceRecursive(element, keepLeadingSpace);\n    }\n\n    return tree;\n  }\n\n  /// [removeUnnecessaryWhitespace] removes \"unnecessary\" white space from the given String.\n  ///\n  /// The steps for removing this whitespace are as follows:\n  /// (1) Remove any whitespace immediately preceding or following a newline.\n  /// (2) Replace all newlines with a space\n  /// (3) Replace all tabs with a space\n  /// (4) Replace any instances of two or more spaces with a single space.\n  static String _removeUnnecessaryWhitespace(String text) {\n    return text\n        .replaceAll(RegExp(\"\\\\ *(?=\\n)\"), \"\\n\")\n        .replaceAll(RegExp(\"(?:\\n)\\\\ *\"), \"\\n\")\n        .replaceAll(\"\\n\", \" \")\n        .replaceAll(\"\\t\", \" \")\n        .replaceAll(RegExp(\" {2,}\"), \" \");\n  }\n\n  /// [processListCharacters] adds list characters to the front of all list items.\n  ///\n  /// The function uses the [_processListCharactersRecursive] function to do most of its work.\n  static StyledElement _processListCharacters(StyledElement tree) {\n    final olStack = ListQueue<Context>();\n    tree = _processListCharactersRecursive(tree, olStack);\n    return tree;\n  }\n\n  /// [_processListCharactersRecursive] uses a Stack of integers to properly number and\n  /// bullet all list items according to the [ListStyleType] they have been given.\n  static StyledElement _processListCharactersRecursive(\n      StyledElement tree, ListQueue<Context> olStack) {\n    tree.style.listStylePosition ??= ListStylePosition.outside;\n    if (tree.name == 'ol' &&\n        tree.style.listStyleType != null &&\n        tree.style.listStyleType!.type == \"marker\") {\n      switch (tree.style.listStyleType!) {\n        case ListStyleType.lowerLatin:\n        case ListStyleType.lowerAlpha:\n        case ListStyleType.upperLatin:\n        case ListStyleType.upperAlpha:\n          olStack.add(Context<String>('a'));\n          if ((tree.attributes['start'] != null\n                  ? int.tryParse(tree.attributes['start']!)\n                  : null) !=\n              null) {\n            var start = int.tryParse(tree.attributes['start']!) ?? 1;\n            var x = 1;\n            while (x < start) {\n              olStack.last.data = olStack.last.data.toString().nextLetter();\n              x++;\n            }\n          }\n          break;\n        default:\n          olStack.add(Context<int>((tree.attributes['start'] != null\n                  ? int.tryParse(tree.attributes['start'] ?? \"\") ?? 1\n                  : 1) -\n              1));\n          break;\n      }\n    } else if (tree.style.display == Display.listItem &&\n        tree.style.listStyleType != null &&\n        tree.style.listStyleType!.type == \"widget\") {\n      tree.style.markerContent = tree.style.listStyleType!.widget!;\n    } else if (tree.style.display == Display.listItem &&\n        tree.style.listStyleType != null &&\n        tree.style.listStyleType!.type == \"image\") {\n      tree.style.markerContent = Image.network(tree.style.listStyleType!.text);\n    } else if (tree.style.display == Display.listItem &&\n        tree.style.listStyleType != null) {\n      String marker = \"\";\n      switch (tree.style.listStyleType!) {\n        case ListStyleType.none:\n          break;\n        case ListStyleType.circle:\n          marker = '○';\n          break;\n        case ListStyleType.square:\n          marker = '■';\n          break;\n        case ListStyleType.disc:\n          marker = '•';\n          break;\n        case ListStyleType.decimal:\n          if (olStack.isEmpty) {\n            olStack.add(Context<int>((tree.attributes['start'] != null\n                    ? int.tryParse(tree.attributes['start'] ?? \"\") ?? 1\n                    : 1) -\n                1));\n          }\n          olStack.last.data += 1;\n          marker = '${olStack.last.data}.';\n          break;\n        case ListStyleType.lowerLatin:\n        case ListStyleType.lowerAlpha:\n          if (olStack.isEmpty) {\n            olStack.add(Context<String>('a'));\n            if ((tree.attributes['start'] != null\n                    ? int.tryParse(tree.attributes['start']!)\n                    : null) !=\n                null) {\n              var start = int.tryParse(tree.attributes['start']!) ?? 1;\n              var x = 1;\n              while (x < start) {\n                olStack.last.data = olStack.last.data.toString().nextLetter();\n                x++;\n              }\n            }\n          }\n          marker = \"${olStack.last.data}.\";\n          olStack.last.data = olStack.last.data.toString().nextLetter();\n          break;\n        case ListStyleType.upperLatin:\n        case ListStyleType.upperAlpha:\n          if (olStack.isEmpty) {\n            olStack.add(Context<String>('a'));\n            if ((tree.attributes['start'] != null\n                    ? int.tryParse(tree.attributes['start']!)\n                    : null) !=\n                null) {\n              var start = int.tryParse(tree.attributes['start']!) ?? 1;\n              var x = 1;\n              while (x < start) {\n                olStack.last.data = olStack.last.data.toString().nextLetter();\n                x++;\n              }\n            }\n          }\n          marker = \"${olStack.last.data.toString().toUpperCase()}.\";\n          olStack.last.data = olStack.last.data.toString().nextLetter();\n          break;\n        case ListStyleType.lowerRoman:\n          if (olStack.isEmpty) {\n            olStack.add(Context<int>((tree.attributes['start'] != null\n                    ? int.tryParse(tree.attributes['start'] ?? \"\") ?? 1\n                    : 1) -\n                1));\n          }\n          olStack.last.data += 1;\n          if (olStack.last.data <= 0) {\n            marker = '${olStack.last.data}.';\n          } else {\n            marker =\n                \"${(olStack.last.data as int).toRomanNumeralString()!.toLowerCase()}.\";\n          }\n          break;\n        case ListStyleType.upperRoman:\n          if (olStack.isEmpty) {\n            olStack.add(Context<int>((tree.attributes['start'] != null\n                    ? int.tryParse(tree.attributes['start'] ?? \"\") ?? 1\n                    : 1) -\n                1));\n          }\n          olStack.last.data += 1;\n          if (olStack.last.data <= 0) {\n            marker = '${olStack.last.data}.';\n          } else {\n            marker = \"${(olStack.last.data as int).toRomanNumeralString()!}.\";\n          }\n          break;\n      }\n      tree.style.markerContent = Text(\n        marker,\n        textAlign: TextAlign.right,\n        style: tree.style.generateTextStyle(),\n      );\n    }\n\n    for (var element in tree.children) {\n      _processListCharactersRecursive(element, olStack);\n    }\n\n    if (tree.name == 'ol') {\n      olStack.removeLast();\n    }\n\n    return tree;\n  }\n\n  /// [_processBeforesAndAfters] adds text content to the beginning and end of\n  /// the list of the trees children according to the `before` and `after` Style\n  /// properties.\n  static StyledElement _processBeforesAndAfters(StyledElement tree) {\n    if (tree.style.before != null) {\n      tree.children.insert(\n        0,\n        TextContentElement(\n          text: tree.style.before,\n          style: tree.style\n              .copyWith(beforeAfterNull: true, display: Display.inline),\n        ),\n      );\n    }\n    if (tree.style.after != null) {\n      tree.children.add(TextContentElement(\n        text: tree.style.after,\n        style:\n            tree.style.copyWith(beforeAfterNull: true, display: Display.inline),\n      ));\n    }\n\n    tree.children.forEach(_processBeforesAndAfters);\n\n    return tree;\n  }\n\n  /// [collapseMargins] follows the specifications at https://www.w3.org/TR/CSS22/box.html#collapsing-margins\n  /// for collapsing margins of block-level boxes. This prevents the doubling of margins between\n  /// boxes, and makes for a more correct rendering of the html content.\n  ///\n  /// Paraphrased from the CSS specification:\n  /// Margins are collapsed if both belong to vertically-adjacent box edges, i.e form one of the following pairs:\n  /// (1) Top margin of a box and top margin of its first in-flow child\n  /// (2) Bottom margin of a box and top margin of its next in-flow following sibling\n  /// (3) Bottom margin of a last in-flow child and bottom margin of its parent (if the parent's height is not explicit)\n  /// (4) Top and Bottom margins of a box with a height of zero or no in-flow children.\n  static StyledElement _collapseMargins(StyledElement tree) {\n    //Short circuit if we've reached a leaf of the tree\n    if (tree.children.isEmpty) {\n      // Handle case (4) from above.\n      if (tree.style.height?.value == 0 &&\n          tree.style.height?.unit != Unit.auto) {\n        tree.style.margin = tree.style.margin?.collapse() ?? Margins.zero;\n      }\n      return tree;\n    }\n\n    //Collapsing should be depth-first.\n    tree.children.forEach(_collapseMargins);\n\n    //The root boxes do not collapse.\n    if (tree.name == '[Tree Root]' || tree.name == 'html') {\n      return tree;\n    }\n\n    // Handle case (1) from above.\n    // Top margins cannot collapse if the element has padding\n    if ((tree.style.padding?.top ?? 0) == 0) {\n      final parentTop = tree.style.margin?.top?.value ?? 0;\n      final firstChildTop = tree.children.first.style.margin?.top?.value ?? 0;\n      final newOuterMarginTop = max(parentTop, firstChildTop);\n\n      // Set the parent's margin\n      if (tree.style.margin == null) {\n        tree.style.margin = Margins.only(top: newOuterMarginTop);\n      } else {\n        tree.style.margin =\n            tree.style.margin!.copyWithEdge(top: newOuterMarginTop);\n      }\n\n      // And remove the child's margin\n      if (tree.children.first.style.margin == null) {\n        tree.children.first.style.margin = Margins.zero;\n      } else {\n        tree.children.first.style.margin =\n            tree.children.first.style.margin!.copyWithEdge(top: 0);\n      }\n    }\n\n    // Handle case (3) from above.\n    // Bottom margins cannot collapse if the element has padding\n    if ((tree.style.padding?.bottom ?? 0) == 0) {\n      final parentBottom = tree.style.margin?.bottom?.value ?? 0;\n      final lastChildBottom =\n          tree.children.last.style.margin?.bottom?.value ?? 0;\n      final newOuterMarginBottom = max(parentBottom, lastChildBottom);\n\n      // Set the parent's margin\n      if (tree.style.margin == null) {\n        tree.style.margin = Margins.only(bottom: newOuterMarginBottom);\n      } else {\n        tree.style.margin =\n            tree.style.margin!.copyWithEdge(bottom: newOuterMarginBottom);\n      }\n\n      // And remove the child's margin\n      if (tree.children.last.style.margin == null) {\n        tree.children.last.style.margin = Margins.zero;\n      } else {\n        tree.children.last.style.margin =\n            tree.children.last.style.margin!.copyWithEdge(bottom: 0);\n      }\n    }\n\n    // Handle case (2) from above.\n    if (tree.children.length > 1) {\n      for (int i = 1; i < tree.children.length; i++) {\n        final previousSiblingBottom =\n            tree.children[i - 1].style.margin?.bottom?.value ?? 0;\n        final thisTop = tree.children[i].style.margin?.top?.value ?? 0;\n        final newInternalMargin = max(previousSiblingBottom, thisTop);\n\n        if (tree.children[i - 1].style.margin == null) {\n          tree.children[i - 1].style.margin =\n              Margins.only(bottom: newInternalMargin);\n        } else {\n          tree.children[i - 1].style.margin = tree.children[i - 1].style.margin!\n              .copyWithEdge(bottom: newInternalMargin);\n        }\n\n        if (tree.children[i].style.margin == null) {\n          tree.children[i].style.margin = Margins.only(top: newInternalMargin);\n        } else {\n          tree.children[i].style.margin = tree.children[i].style.margin!\n              .copyWithEdge(top: newInternalMargin);\n        }\n      }\n    }\n\n    return tree;\n  }\n\n  /// [removeEmptyElements] recursively removes empty elements.\n  ///\n  /// An empty element is any [EmptyContentElement], any empty [TextContentElement],\n  /// or any block-level [TextContentElement] that contains only whitespace and doesn't follow\n  /// a block element or a line break.\n  static StyledElement _removeEmptyElements(StyledElement tree) {\n    List<StyledElement> toRemove = <StyledElement>[];\n    bool lastChildBlock = true;\n    tree.children.forEachIndexed((index, child) {\n      if (child is EmptyContentElement || child is EmptyLayoutElement) {\n        toRemove.add(child);\n      } else if (child is TextContentElement &&\n          ((tree.name == \"body\" &&\n                  (index == 0 ||\n                      index + 1 == tree.children.length ||\n                      tree.children[index - 1].style.display == Display.block ||\n                      tree.children[index + 1].style.display ==\n                          Display.block)) ||\n              tree.name == \"ul\") &&\n          child.text!.replaceAll(' ', '').isEmpty) {\n        toRemove.add(child);\n      } else if (child is TextContentElement &&\n          child.text!.isEmpty &&\n          child.style.whiteSpace != WhiteSpace.pre) {\n        toRemove.add(child);\n      } else if (child is TextContentElement &&\n          child.style.whiteSpace != WhiteSpace.pre &&\n          tree.style.display == Display.block &&\n          child.text!.isEmpty &&\n          lastChildBlock) {\n        toRemove.add(child);\n      } else if (child.style.display == Display.none) {\n        toRemove.add(child);\n      } else {\n        _removeEmptyElements(child);\n      }\n\n      // This is used above to check if the previous element is a block element or a line break.\n      lastChildBlock = (child.style.display == Display.block ||\n          child.style.display == Display.listItem ||\n          (child is TextContentElement && child.text == '\\n'));\n    });\n    tree.children.removeWhere((element) => toRemove.contains(element));\n\n    return tree;\n  }\n\n  /// [_calculateRelativeValues] converts rem values to px sizes and then\n  /// applies relative calculations\n  static StyledElement _calculateRelativeValues(\n      StyledElement tree, double devicePixelRatio) {\n    double remSize = (tree.style.fontSize?.value ?? FontSize.medium.value);\n\n    //If the root element has a rem-based fontSize, then give it the default\n    // font size times the set rem value.\n    if (tree.style.fontSize?.unit == Unit.rem) {\n      tree.style.fontSize = FontSize(FontSize.medium.value * remSize);\n    }\n\n    _applyRelativeValuesRecursive(tree, remSize, devicePixelRatio);\n    tree.style.setRelativeValues(remSize, remSize / devicePixelRatio);\n\n    return tree;\n  }\n\n  /// This is the recursive worker function for [_calculateRelativeValues]\n  static void _applyRelativeValuesRecursive(\n      StyledElement tree, double remFontSize, double devicePixelRatio) {\n    //When we get to this point, there should be a valid fontSize at every level.\n    assert(tree.style.fontSize != null);\n\n    final parentFontSize = tree.style.fontSize!.value;\n\n    for (var child in tree.children) {\n      if (child.style.fontSize == null) {\n        child.style.fontSize = FontSize(parentFontSize);\n      } else {\n        switch (child.style.fontSize!.unit) {\n          case Unit.em:\n            child.style.fontSize =\n                FontSize(parentFontSize * child.style.fontSize!.value);\n            break;\n          case Unit.percent:\n            child.style.fontSize = FontSize(\n                parentFontSize * (child.style.fontSize!.value / 100.0));\n            break;\n          case Unit.rem:\n            child.style.fontSize =\n                FontSize(remFontSize * child.style.fontSize!.value);\n            break;\n          case Unit.px:\n          case Unit.auto:\n            //Ignore\n            break;\n        }\n      }\n\n      // Note: it is necessary to scale down the emSize by the factor of\n      // devicePixelRatio since Flutter seems to calculates font sizes using\n      // physical pixels, but margins/padding using logical pixels.\n      final emSize = child.style.fontSize!.value / devicePixelRatio;\n\n      tree.style.setRelativeValues(remFontSize, emSize);\n\n      _applyRelativeValuesRecursive(child, remFontSize, devicePixelRatio);\n    }\n  }\n}\n\n/// The [RenderContext] is available when parsing the tree. It contains information\n/// about the [BuildContext] of the `Html` widget, contains the configuration available\n/// in the [HtmlParser], and contains information about the [Style] of the current\n/// tree root.\nclass RenderContext {\n  final BuildContext buildContext;\n  final HtmlParser parser;\n  final StyledElement tree;\n  final Style style;\n  final AnchorKey? key;\n\n  RenderContext({\n    required this.buildContext,\n    required this.parser,\n    required this.tree,\n    required this.style,\n    this.key,\n  });\n}\n\nextension IterateLetters on String {\n  String nextLetter() {\n    String s = toLowerCase();\n    if (s == \"z\") {\n      return String.fromCharCode(s.codeUnitAt(0) - 25) +\n          String.fromCharCode(s.codeUnitAt(0) - 25); // AA or aa\n    } else {\n      var lastChar = s.substring(s.length - 1);\n      var sub = s.substring(0, s.length - 1);\n      if (lastChar == \"z\") {\n        // If a string of length > 1 ends in Z/z,\n        // increment the string (excluding the last Z/z) recursively,\n        // and append A/a (depending on casing) to it\n        return '${sub.nextLetter()}a';\n      } else {\n        // (take till last char) append with (increment last char)\n        return sub + String.fromCharCode(lastChar.codeUnitAt(0) + 1);\n      }\n    }\n  }\n}\n"
        }
    ]
}